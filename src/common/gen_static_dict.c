#include <common/debug.h>
#include <common/defs.h>
#include <common/dict.h>
#include <common/bithacks.h>
#include <common/mm.h>
#include <common/init_cleanup_list.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

init_func_t init_funcs[] = {
	
};

cleanup_func_t cleanup_funcs[] = {
	
};

int
main(int argc, char * argv[])
{
	dbg_init(NULL);
	if (argc < 3) {
		printf("%s <nr> <sz> <str1> <str2> ...\n", argv[0]);
		return 0;
	}

	/* check */
	int nr = atoi(argv[1]);
	printf("/* nr: %d */\n", nr);
	if (nr <= 0) {
		printf("nr error\n");
		return -1;
	}

	int sz = atoi(argv[2]);
	printf("/* sz: %d */\n", sz);
	if (sz < 8) {
		printf("sz must larger than 8\n");
		return -1;
	}

	sz = pow2roundup(sz);

	struct dict_t * d = strdict_create(sz, STRDICT_FL_FIXED);

	for (int i = 3; i < 3 + nr; i++) {
		assert(argv[i] != NULL);
		char * arg = strdup(argv[i]);
		char * peq = strchr(arg, '=');
		dict_data_t dt;
		if (peq == NULL) {
			dt = strdict_insert(d, argv[i], (dict_data_t)(void*)NULL);
		} else {
			*peq = '\0';
			char * key = arg;
			char * value = peq + 1;
			dt = strdict_insert(d, key, (dict_data_t)(void*)value);
		}
		assert(DICT_DATA_NULL(dt));
	}

	if (argv[3 + nr] == NULL) {
		for (int i = 0; i < sz; i ++) {
			struct dict_entry_t * e = &(d->ptable[i]);
			printf("/* %8d|%20s|0x%x|%s */\n",
					i, (char*)(e->key), e->hash, e->data.str);
		}
	} else {
		printf("static struct dict_entry_t %s_table[%d] = {\n", argv[3+nr], sz);
		for (int i = 0; i < sz; i++) {
			struct dict_entry_t * e = &(d->ptable[i]);
			if (e->key != NULL) {
				printf("\t[%d] = {\n", i);
				printf("\t\t.key = \"%s\",\n", (const char *)(e->key));
				printf("\t\t.hash = 0x%x,\n", e->hash);

				if (e->data.ptr != NULL) {
					if (argv[3+nr+1] == NULL)
						printf("\t\t.data = {.ptr = %s},\n", e->data.str);
					else if (strcmp(argv[3+nr+1], "str") == 0)
						printf("\t\t.data = {.%s = \"%s\"},\n",
								argv[3+nr+1], e->data.str);
					else
						printf("\t\t.data = {.%s = %s},\n",
								argv[3+nr+1], e->data.str);
				} else {
					printf("\t\t.data = {.ptr = NULL},\n");
				}
				printf("\t},\n");
			}
		}
		printf("};\n\n");

		printf("static struct dict_t %s_dict = {\n", argv[3 + nr]);
		printf("\t.nr_fill = %d,\n", nr);
		printf("\t.nr_used = %d,\n", nr);
		printf("\t.mask = %d,\n", sz - 1);
		printf("\t.flags = DICT_FL_STRKEY | DICT_FL_FIXED,\n");
		printf("\t.private = STRDICT_FL_FIXED,\n");
		printf("\t.ptable = %s_table,\n", argv[3 + nr]);
		printf("};\n\n");
	}

	printf("/* generated by: */\n/* ");
	for (int i = 0; i < argc; i++) {
		printf("%s ", argv[i]);
	}
	printf("*/\n");

	return 0;
}

// vim:ts=4:sw=4

